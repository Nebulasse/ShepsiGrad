# Руководство по тестированию бэкенда ShepsiGrad

## Введение

Это руководство описывает подход к тестированию бэкенд-сервиса приложения ShepsiGrad.

## Структура тестов

Тесты для бэкенда расположены в директории `src/tests/` и разделены на:

- `unit/` - модульные тесты для отдельных компонентов (контроллеры, сервисы)
- `integration/` - интеграционные тесты для API-эндпоинтов

## Запуск тестов

```bash
# Запуск всех тестов
npm run test

# Запуск только модульных тестов
npm run test:unit

# Запуск только интеграционных тестов
npm run test:integration

# Запуск тестов с покрытием кода
npm run test:coverage
```

## Модульные тесты

### Контроллеры

Модульные тесты для контроллеров проверяют корректность обработки HTTP-запросов, валидации данных и формирования ответов.

Пример теста для контроллера бронирований (`bookingController.test.ts`):

```typescript
describe("BookingController", () => {
  // Настройка мока для запроса и ответа
  let mockRequest: Partial<Request>;
  let mockResponse: Partial<Response>;
  let responseObject: any;

  beforeEach(() => {
    responseObject = {
      json: jest.fn(),
      status: jest.fn().mockReturnThis(),
    };
    mockRequest = {};
    mockResponse = responseObject;
  });

  // Тест для метода создания бронирования
  it("should create a booking", async () => {
    // Настройка моков и входных данных
    // Вызов тестируемого метода
    // Проверка результатов
  });
});
```

### Сервисы

Модульные тесты для сервисов проверяют бизнес-логику приложения, обработку данных и взаимодействие с внешними API.

Пример теста для платежного сервиса (`paymentService.test.ts`):

```typescript
describe("PaymentService", () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  // Тест для метода создания платежа
  it("should create a payment", async () => {
    // Настройка моков и входных данных
    // Вызов тестируемого метода
    // Проверка результатов
  });

  // Тест для обработки ошибок
  it("should handle payment error", async () => {
    // Настройка моков для имитации ошибки
    // Вызов тестируемого метода
    // Проверка обработки ошибки
  });
});
```

## Интеграционные тесты

Интеграционные тесты проверяют взаимодействие между различными компонентами системы и корректность работы API-эндпоинтов.

Пример интеграционного теста для API бронирований (`booking.test.ts`):

```typescript
describe("Booking API", () => {
  // Создаем тестовый токен для авторизации
  const testUserId = "user123";
  const testToken = jwt.sign({ id: testUserId }, config.jwt.secret, {
    expiresIn: "1h",
  });

  beforeEach(() => {
    jest.clearAllMocks();
  });

  // Тест для получения списка бронирований
  describe("GET /api/bookings", () => {
    it("should return user bookings", async () => {
      // Настройка моков
      // Выполнение запроса к API
      // Проверка результатов
    });
  });
});
```

## Моки и стабы

Для изоляции тестируемого кода от внешних зависимостей используются моки и стабы:

```typescript
// Мокаем модели и сервисы
jest.mock("../../models/Booking");
jest.mock("../../models/Property");
jest.mock("../../services/paymentService");

// Мокаем внешние библиотеки
jest.mock("axios");
jest.mock("uuid", () => ({
  v4: jest.fn().mockReturnValue("test-uuid-1234"),
}));
```

## Рекомендации по написанию тестов

1. **Изоляция тестов**: Каждый тест должен быть независимым от других тестов
2. **Моки для внешних зависимостей**: Используйте моки для баз данных, API и других внешних сервисов
3. **Проверка граничных случаев**: Тестируйте не только успешные сценарии, но и обработку ошибок
4. **Читаемые названия тестов**: Используйте описательные названия для тестов, отражающие проверяемое поведение
5. **Настройка и очистка**: Используйте `beforeEach` и `afterEach` для настройки и очистки тестового окружения

## Известные проблемы и решения

### Проблемы с TypeScript

При запуске тестов могут возникать ошибки типизации. Для их решения:

1. Используйте опцию `isolatedModules: true` в конфигурации Jest
2. Временно отключите строгую проверку типов в тестах

### Моки для баз данных

Для тестирования без реальной базы данных:

1. Создайте моки для моделей данных
2. Используйте in-memory базы данных для интеграционных тестов

## Дальнейшие улучшения

1. Увеличить покрытие кода тестами (целевой показатель: 80%)
2. Добавить тесты производительности для критичных эндпоинтов
3. Настроить CI/CD для автоматического запуска тестов
4. Добавить E2E-тесты для проверки полного пользовательского пути
